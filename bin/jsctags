#!/usr/bin/env node
'use strict'

var jsctags = require('../');
var path = require('path');
var async = require('async');
var fs = require('fs');
var diveSync = require('diveSync')
var program = require('commander');
var globToRegexp = require('glob-to-regexp');

const glob = pattern => globToRegexp(pattern, {flags: 'i'})

// Process `exclude` arg
function exclude(patterns) {
  return patterns.split(',').map(pattern => glob(pattern))
}

program
.arguments('<file> [others...]')
.option('-R, --recurse', 'Recurse into directories')
.option('--exclude  <patterns>', 'Comma separated list of exclusion patterns. Exclude files and directories matching one of the `patterns`.', exclude)
.option('-f <name>', 'Write tags to specified file. Value of "-" writes tags to stdout ["tags"; or "TAGS" when -e supplied].')
.option('--extension <extension>', 'File extension to look for. Default is `.js`', 'js')
.action((file, others) => {
  const projectDir = path.resolve('.')

  // Filtering
  const extension = new RegExp(`.*\.${program.extension}$`)
  // Always exclude `node_modules` and '.git' folders
  var patterns = [glob('*/node_modules/*'), glob('*/.git/*')]
  if (program.exclude) {
    patterns = patterns.concat(program.exclude)
  }
  function filter(path, dir) {
    if (!dir && !extension.test(path)) {
      return false
    }
    return patterns.every(pattern => !pattern.test(path))
  }

  // Resolve files
  const files = []
  const items = others.concat(file).map(item => path.resolve(item))
  items.forEach(item => {
    if (fs.statSync(item).isDirectory()) {
      diveSync(
        item,
        {recursive: program.recurse, filter: filter },
        (err, file) => {
          files.push(file)
        })
    } else {
      if (!filter(file, false)) {
        files.push(file)
      }
    }
  })

  // Process each file
  async.map(files, (file, callback) => {
    const content = fs.readFileSync(file, 'utf8')

    // Generate tags
    jsctags({
      file: file,
      dir: projectDir,
      content: content
    }, function (err, tags) {
      if (err) {
        throw err;
      }

      tags.tagfile = file;
      tags.forEach(function (tag) {
        tag.tagfile = file;
      });
        callback(null, tags);
    });
  }, (err, results) => {
    if (err) {
      throw err;
    }

    // Convert to ctags format
    const ctags = results.map(tags => {
      return jsctags.ctags(tags, {args:false , local: false})
    }).sort()

    // Output
    if (program.F === '-') {
      console.log(ctags.join(''));
    } else {
      fs.writeFile('tags', ctags, err => {
        if(err) {
          throw err
        }
      })
    }
  })
})
.parse(process.argv);
