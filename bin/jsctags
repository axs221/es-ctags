#!/usr/bin/env node
'use strict'

var jsctags = require('../');
var path = require('path');
var async = require('async');
var fs = require('fs');
var diveSync = require('diveSync')
var program = require('commander');
var globToRegexp = require('glob-to-regexp');

const glob = pattern => globToRegexp(pattern, {flags: 'i'})

// Process `exclude` arg
function exclude(patterns) {
  return patterns.split(',').map(pattern => glob(pattern))
}

program
.arguments('<file> [others...]')
.option('-R, --recurse', 'Recurse into directories')
.option('-a, --append', 'Append the tags to an existing tag file.')
.option('--exclude  <patterns>', 'Comma separated list of exclusion patterns. Exclude files and directories matching one of the `patterns`.', exclude)
.option('-f <name>', 'Write tags to specified file. Value of "-" writes tags to stdout ["tags"; or "TAGS" when -e supplied].', 'tags')
.option('--extension <extension>', 'File extension to look for. Default is `.js`', 'js')
.action((file, others) => {
  const projectDir = path.resolve('.')

  // Filtering
  const extension = new RegExp(`.*\.${program.extension}$`)
  // Always exclude `node_modules` and '.git' folders
  var patterns = [glob('*/node_modules/*'), glob('*/.git/*')]
  if (program.exclude) {
    patterns = patterns.concat(program.exclude)
  }
  function filter(path, dir) {
    if (!dir && !extension.test(path)) {
      return true
    }
    return patterns.some(pattern => pattern.test(path))
  }

  // Resolve files
  const files = []
  others.push(file)
  let items = others.map(other => other.replace(/\"/g, ''))
  items = items.map(item => path.resolve(item))
  items.forEach(item => {
    if (fs.statSync(item).isDirectory()) {
      if (program.recurse) {
        diveSync(
          item,
          {recursive: program.recurse, filter: (path, dir) => !filter(path, dir) },
          (err, file) => {
            files.push(file)
          })
      }
    } else {
      if (!filter(item, false)) {
        files.push(item)
      }
    }
  })

  // Process each file
  async.map(files, (file, callback) => {
    const content = fs.readFileSync(file, 'utf8')

    // Generate tags
    jsctags({
      file: file,
      dir: projectDir,
      content: content
    }, function (err, tags) {
      if (err) {
        throw err;
      }

      tags.tagfile = file;
      tags.forEach(function (tag) {
        tag.tagfile = file;
      });
        callback(null, tags);
    });
  }, (err, results) => {
    if (err) {
      throw err;
    }

    // Convert to ctags format
    let ctags = results.map(tags => {
      return jsctags.ctags(tags, {args:false , local: false})
    })

    // flatten
    ctags = [].concat.apply([], ctags)

    // Append
    if (program.append) {
      let previous = ''
      try {
        previous = fs.readFileSync(program.F, {encoding: 'utf8'})
      } catch (e) {
        if (e.code !== 'ENOENT') {
          throw e;
        } //   // but you also get any other error
      }
      // split on new lines/carriage returns
      previous = previous.split(/\r\n|\r|\n/g);
      // remove empty lines
      previous = previous.filter(line => line !== '')
      // add new line
      previous = previous.map(line => `${line}\n`)
      // merge with parsed ctags
      ctags = previous.concat(ctags)
    }

    // Sort
    ctags = ctags.sort()

    // Convert to string
    ctags = ctags.join('')

    // Output
    if (program.F === '-') {
        console.log(ctags)
    } else {
      fs.writeFileSync(program.F, ctags)
    }
  })
})
.parse(process.argv);

if (program.args.length === 0) {
  console.log('jsctags: No files specified. Try "jsctags --help".')
}

